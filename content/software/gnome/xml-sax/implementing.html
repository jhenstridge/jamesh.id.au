<!DOCTYPE HTML PUBLIC "-//Norman Walsh//DTD DocBook HTML 1.0//EN">
<HTML
><HEAD
><TITLE
>Implementing a SAX Based Parser</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet"><LINK
REL="HOME"
TITLE="Using the SAX Interface of LibXML"
HREF="xml-sax.html"><LINK
REL="PREVIOUS"
TITLE="Using the SAX Interface of LibXML"
HREF="xml-sax.html"><LINK
REL="NEXT"
TITLE="Conclusion"
HREF="conclusion.html"></HEAD
><BODY
><DIV
CLASS="NAVHEADER"
><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>Using the SAX Interface of LibXML</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="xml-sax.html"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="conclusion.html"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="IMPLEMENTING"
>Implementing a SAX Based Parser</A
></H1
><P
>Now you should have a pretty good idea about what a SAX
    parser is, and how you might implement one using a state machine
    design.  Now it is time to learn how to implement the parser using
    libxml's C translation of the SAX interface.</P
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="BASICS"
>The Basics</A
></H2
><P
>As stated before, you use the SAX parser by passing a
      number of callback routines stored in a
      <SPAN
CLASS="STRUCTNAME"
>xmlSAXHandler</SPAN
> structure to one of the
      SAX parser routines.  Here is the prototype for the
      structure:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>typedef struct <SPAN
CLASS="STRUCTNAME"
>xmlSAXHandler</SPAN
> {
    internalSubsetSAXFunc <TT
CLASS="STRUCTFIELD"
><I
>internalSubset</I
></TT
>;
    isStandaloneSAXFunc <TT
CLASS="STRUCTFIELD"
><I
>isStandalone</I
></TT
>;
    hasInternalSubsetSAXFunc <TT
CLASS="STRUCTFIELD"
><I
>hasInternalSubset</I
></TT
>;
    hasExternalSubsetSAXFunc <TT
CLASS="STRUCTFIELD"
><I
>hasExternalSubset</I
></TT
>;
    resolveEntitySAXFunc <TT
CLASS="STRUCTFIELD"
><I
>resolveEntity</I
></TT
>;
    getEntitySAXFunc <TT
CLASS="STRUCTFIELD"
><I
>getEntity</I
></TT
>;
    entityDeclSAXFunc <TT
CLASS="STRUCTFIELD"
><I
>entityDecl</I
></TT
>;
    notationDeclSAXFunc <TT
CLASS="STRUCTFIELD"
><I
>notationDecl</I
></TT
>;
    attributeDeclSAXFunc <TT
CLASS="STRUCTFIELD"
><I
>attributeDecl</I
></TT
>;
    elementDeclSAXFunc <TT
CLASS="STRUCTFIELD"
><I
>elementDecl</I
></TT
>;
    unparsedEntityDeclSAXFunc <TT
CLASS="STRUCTFIELD"
><I
>unparsedEntityDecl</I
></TT
>;
    setDocumentLocatorSAXFunc <TT
CLASS="STRUCTFIELD"
><I
>setDocumentLocator</I
></TT
>;
    startDocumentSAXFunc <TT
CLASS="STRUCTFIELD"
><I
>startDocument</I
></TT
>;
    endDocumentSAXFunc <TT
CLASS="STRUCTFIELD"
><I
>endDocument</I
></TT
>;
    startElementSAXFunc <TT
CLASS="STRUCTFIELD"
><I
>startElement</I
></TT
>;
    endElementSAXFunc <TT
CLASS="STRUCTFIELD"
><I
>endElement</I
></TT
>;
    referenceSAXFunc <TT
CLASS="STRUCTFIELD"
><I
>reference</I
></TT
>;
    charactersSAXFunc <TT
CLASS="STRUCTFIELD"
><I
>characters</I
></TT
>;
    ignorableWhitespaceSAXFunc <TT
CLASS="STRUCTFIELD"
><I
>ignorableWhitespace</I
></TT
>;
    processingInstructionSAXFunc <TT
CLASS="STRUCTFIELD"
><I
>processingInstruction</I
></TT
>;
    commentSAXFunc <TT
CLASS="STRUCTFIELD"
><I
>comment</I
></TT
>;
    warningSAXFunc <TT
CLASS="STRUCTFIELD"
><I
>warning</I
></TT
>;
    errorSAXFunc <TT
CLASS="STRUCTFIELD"
><I
>error</I
></TT
>;
    fatalErrorSAXFunc <TT
CLASS="STRUCTFIELD"
><I
>fatalError</I
></TT
>;
} <SPAN
CLASS="STRUCTNAME"
>xmlSAXHandler</SPAN
>;
typedef <SPAN
CLASS="STRUCTNAME"
>xmlSAXHandler</SPAN
> *xmlSAXHandlerPtr;</PRE
></TD
></TR
></TABLE
><P
>To start off with, we can set all these functions to NULL.
      If we use a NULL SAX parser like this, then we will have a
      parser that only checks the well formedness of a document.  By
      adding a few callbacks, we can get it to do just about
      anything.</P
><P
>If you do not care about reentrancy of your parser, you
      can save state between callbacks in global variables.  If you
      choose this approach, you could use one of the following
      functions:</P
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;parser.h&#62;</PRE
></TD
></TR
></TABLE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>xmlDocPtr <B
CLASS="FSFUNC"
>xmlSAXParseFile</B
></CODE
>(xmlSAXHandlerPtr <VAR
CLASS="PDPARAM"
>sax</VAR
>, const char *<VAR
CLASS="PDPARAM"
>filename</VAR
>, int <VAR
CLASS="PDPARAM"
>recovery</VAR
>);</CODE
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>xmlDocPtr <B
CLASS="FSFUNC"
>xmlSAXParseMemory</B
></CODE
>(xmlSAXHandlerPtr <VAR
CLASS="PDPARAM"
>sax</VAR
>, char *<VAR
CLASS="PDPARAM"
>buffer</VAR
>, int <VAR
CLASS="PDPARAM"
>size</VAR
>, int <VAR
CLASS="PDPARAM"
>recovery</VAR
>);</CODE
></P
><P
></P
></DIV
><P
>In these functions, you will most likely ignore the return
      type (it will probably contain a NULL or garbage).  However, if
      you want to write a reentrant parser, you will need to make some
      changes.  A <TT
CLASS="PARAMETER"
><I
>user_data</I
></TT
> parameter is passed
      to all SAX callbacks, which can be used to pass state
      information between callbacks.  Unfortunately, with the current
      libxml API, there is not an easy way to set this parameter, so
      you will need to include a rewritten version of
      <TT
CLASS="FUNCTION"
><B
>xmlSAXParseFile</B
></TT
> in your program.  Daniel
      says that he will probably change the above functions in a
      future version to be more useful in this case.  Until then, you
      will probably want to use a function like this:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>#include &#60;parser.h&#62;
#include &#60;parserInternals.h&#62;

int <TT
CLASS="FUNCTION"
><B
>myXmlSAXParseFile</B
></TT
>(xmlSAXHandlerPtr <TT
CLASS="PARAMETER"
><I
>sax</I
></TT
>, void *<TT
CLASS="PARAMETER"
><I
>user_data</I
></TT
>, const char *<TT
CLASS="PARAMETER"
><I
>filename</I
></TT
>) {
    int ret = 0;
    xmlParserCtxtPtr ctxt;

    ctxt = xmlCreateFileParserCtxt(filename);
    if (ctxt == NULL) return -1;
    ctxt-&#62;sax = sax;
    ctxt-&#62;userData = user_data;

    xmlParseDocument(ctxt);

    if (ctxt-&#62;wellFormed)
        ret = 0;
    else
        ret = -1;
    if (sax != NULL)
        ctxt-&#62;sax = NULL;
    xmlFreeParserCtxt(ctxt);
    
    return ret;
}</PRE
></TD
></TR
></TABLE
><P
>This function could then be used like so:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>static <SPAN
CLASS="STRUCTNAME"
>xmlSAXHandler</SPAN
> my_handler {
    ...
};

struct <SPAN
CLASS="STRUCTNAME"
>ParserState</SPAN
> {
    RetVal <TT
CLASS="STRUCTFIELD"
><I
>return_val</I
></TT
>;
    StatesEnum <TT
CLASS="STRUCTFIELD"
><I
>state</I
></TT
>;
    ...
};

RetVal <TT
CLASS="FUNCTION"
><B
>parse_xml_file</B
></TT
>(const char *<TT
CLASS="PARAMETER"
><I
>filename</I
></TT
>) {
    struct ParserState my_state;

    if (myXmlSAXParseFile(&#38;my_handler, &#38;my_state, filename) &#60; 0) {
        free_ret_val(my_state.return_val);
        return NULL;
    } else
        return my_state.return_val;
}</PRE
></TD
></TR
></TABLE
><P
>In this example, we expect the
      <TT
CLASS="FUNCTION"
><B
>startDocument</B
></TT
> SAX handler to initialise the
      <SPAN
CLASS="STRUCTNAME"
>ParserState</SPAN
> structure passed to it, and
      the <TT
CLASS="FUNCTION"
><B
>endDocument</B
></TT
> to free its members, but
      leaving <TT
CLASS="STRUCTFIELD"
><I
>return_val</I
></TT
> so that it can be
      used later.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="START-END-DOC"
>The startDocument and endDocument Callbacks</A
></H2
><P
>These callbacks are generally used to perform some
      initialisation and deinitialisation for your parser callbacks.
      Their prototypes are as follows:</P
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>void <B
CLASS="FSFUNC"
>startDocument</B
></CODE
>(void *<VAR
CLASS="PDPARAM"
>user_data</VAR
>);</CODE
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>void <B
CLASS="FSFUNC"
>endDocument</B
></CODE
>(void *<VAR
CLASS="PDPARAM"
>user_data</VAR
>);</CODE
></P
><P
></P
></DIV
><P
>It should be fairly self explanatory how to write these
      functions.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="CHARACTERS"
>The characters Callback</A
></H2
><P
>The <TT
CLASS="FUNCTION"
><B
>characters</B
></TT
> callback is called
      when there are characters that are outside of tags get parsed.
      Its prototype is as follows:</P
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>void <B
CLASS="FSFUNC"
>characters</B
></CODE
>(void *<VAR
CLASS="PDPARAM"
>user_data</VAR
>, const CHAR *<VAR
CLASS="PDPARAM"
>ch</VAR
>, int <VAR
CLASS="PDPARAM"
>len</VAR
>);</CODE
></P
><P
></P
></DIV
><P
>The <SPAN
CLASS="TYPE"
>CHAR</SPAN
> type is an alias for
      <SPAN
CLASS="TYPE"
>char</SPAN
>.  It is used so that it will be easier to add
      unicode support to the parser at a later date.  For all intents
      and purposes though, you can think of <TT
CLASS="PARAMETER"
><I
>ch</I
></TT
>
      as an array of <SPAN
CLASS="TYPE"
>char</SPAN
>'s.  Note that the character
      data is not necessarily nul terminated.  This is so that libxml
      does not need to copy the character data out of its internal
      buffers before passing it to the callback.</P
><P
>In your callback, you will probably want to copy the
      characters to some other buffer so that it can be used from the
      endElement callback.  To optimise this callback a bit, you might
      adjust the callback so that it only copies the characters if the
      parser is in a certain state.  Note that the
      <TT
CLASS="FUNCTION"
><B
>characters</B
></TT
> callback may be called more than
      once between calls to <TT
CLASS="FUNCTION"
><B
>startElement</B
></TT
> and
      <TT
CLASS="FUNCTION"
><B
>endElement</B
></TT
>.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="START-END-ELEMENT"
>The startElement and endElement Callbacks</A
></H2
><P
>These callbacks are where most of the state machine logic
      will go into these two callbacks.  Their prototypes are:</P
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>void <B
CLASS="FSFUNC"
>startElement</B
></CODE
>(void *<VAR
CLASS="PDPARAM"
>user_data</VAR
>, const CHAR *<VAR
CLASS="PDPARAM"
>name</VAR
>, const CHAR **<VAR
CLASS="PDPARAM"
>attrs</VAR
>);</CODE
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>void <B
CLASS="FSFUNC"
>endElement</B
></CODE
>(void *<VAR
CLASS="PDPARAM"
>user_data</VAR
>, const CHAR *<VAR
CLASS="PDPARAM"
>name</VAR
>);</CODE
></P
><P
></P
></DIV
><P
>In these callbacks, the <TT
CLASS="PARAMETER"
><I
>name</I
></TT
>
      parameter is the name of the element.  The
      <TT
CLASS="PARAMETER"
><I
>attrs</I
></TT
> parameter contains the attributes
      for the start tag.  The even indices in the array will be
      attribute names, the odd indices are the values, and the final
      index will contain a NULL.</P
><P
>In most parsers, as well as making state transitions in
      these callbacks, you will probably also collect the data in the
      XML file. In the <TT
CLASS="FUNCTION"
><B
>startElement</B
></TT
> callback, you
      will often allocate structures to hold the data.  In the
      <TT
CLASS="FUNCTION"
><B
>endElement</B
></TT
> callback, you will usually
      interpret the character data collected by the
      <TT
CLASS="FUNCTION"
><B
>characters</B
></TT
> callback and put the data in one
      of the structures allocated by
      <TT
CLASS="FUNCTION"
><B
>startElement</B
></TT
>.  The
      <TT
CLASS="FUNCTION"
><B
>endElement</B
></TT
> callback may also free some of
      the intermediate structures if it is no longer needed.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="ENTITIES"
>The getEntity Callback</A
></H2
><P
>You may have been wondering how entities (eg &#38;lt;,
      etc) are handled by the SAX interface.  This is done by the
      <TT
CLASS="FUNCTION"
><B
>getEntity</B
></TT
> callback:</P
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>xmlEntityPtr <B
CLASS="FSFUNC"
>getEntity</B
></CODE
>(void *<VAR
CLASS="PDPARAM"
>user_data</VAR
>, const CHAR *<VAR
CLASS="PDPARAM"
>name</VAR
>);</CODE
></P
><P
></P
></DIV
><P
>The <SPAN
CLASS="STRUCTNAME"
>xmlEntity</SPAN
> structure holds
      some information about the entity.  This structure will not be
      freed by the parser, so it makes sense to create these
      structures once, and then pass a pointer to the appropriate one
      when this function is called.  After calling
      <TT
CLASS="FUNCTION"
><B
>getEntity</B
></TT
>, the expansion of the entity is
      passed to the <TT
CLASS="FUNCTION"
><B
>characters</B
></TT
> callback.  This
      way, you do not need to worry about decoding entities anywhere
      else in your callback routines.</P
><P
>If your XML document only contains the standard entities
      (&#38;lt;, &#38;gt;, &#38;apos;, &#38;quot; and &#38;amp;), then
      it is possible to write a very short implementation for this
      callback:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>static xmlEntityPtr my_getEntity(void *user_data, const CHAR *name) {
    return xmlGetPredefinedEntity(name);
}</PRE
></TD
></TR
></TABLE
><P
>For most parsers, this will be sufficient.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="ERRORS"
>Structural Errors</A
></H2
><P
>If there are structural errors in the XML file, the parser
      will call one of three error callbacks:
      <TT
CLASS="FUNCTION"
><B
>warning</B
></TT
>, <TT
CLASS="FUNCTION"
><B
>error</B
></TT
> or
      <TT
CLASS="FUNCTION"
><B
>fatalError</B
></TT
>.</P
><P
>If you want to pass these errors to the standard glib
      logging functions, you might want to use an implementation
      something like this:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>static void my_warning(void *user_data, const char *msg, ...) {
    va_list args;

    va_start(args, msg);
    g_logv("XML", G_LOG_LEVEL_WARNING, msg, args);
    va_end(args);
}

static void my_error(void *user_data, const char *msg, ...) {
    va_list args;

    va_start(args, msg);
    g_logv("XML", G_LOG_LEVEL_CRITICAL, msg, args);
    va_end(args);
}

static void my_fatalError(void *user_data, const char *msg, ...) {
    va_list args;

    va_start(args, msg);
    g_logv("XML", G_LOG_LEVEL_ERROR, msg, args);
    va_end(args);
}</PRE
></TD
></TR
></TABLE
><P
>Note that libxml is not a validating parser, so only
      structural errors will be picked up.  So any validation of the
      format will have to be done by your parser routines.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="EXPANSION"
>How to Handle an Expanding File Format</A
></H2
><P
>With most applications, you will want to add to the XML
      file format as you add features to the application.  For this
      reason, you will want to code your callbacks so that they don't
      barf on an unknown or unexpected tag.</P
><P
>With the DOM style interface, if you come to a node with
      an unexpected name, you will usually ignore it, and the subtree
      under it.  It is probably a good idea to use a similar process
      for a SAX based parser.</P
><P
>To implement this sort of error recovery, we will need an
      extra state for the parser -- UNKNOWN.  We will also need to
      pass two extra variables in the <TT
CLASS="PARAMETER"
><I
>user_data</I
></TT
>
      parameter to the callbacks -- prev_state and unknown_depth.</P
><P
>When we hit an unknown element in the
      <TT
CLASS="FUNCTION"
><B
>startElement</B
></TT
> callback, we can save the
      current state to prev_state, and then change the state to
      UNKNOWN, and set unknown_depth to 1.  If
      <TT
CLASS="FUNCTION"
><B
>startElement</B
></TT
> is called while in the UNKNOWN
      state, we increment the unknown_depth variable.</P
><P
>In the <TT
CLASS="FUNCTION"
><B
>endElement</B
></TT
> callback, if we are
      in the UNKNOWN state, decrement unknown_depth.  If unknown_depth
      is zero, change the state to prev_state.  The
      <TT
CLASS="FUNCTION"
><B
>characters</B
></TT
> callback should probably return
      immediately if in the UNKNOWN state as well.</P
><P
>Using this sort of logic, it should be possible to ignore
      unknown sections of the document quite easily.  The UNKNOWN
      state is also useful when writing the parser.  This way you can
      test out portions of the parser before it is complete.</P
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="xml-sax.html"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="xml-sax.html"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="conclusion.html"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Using the SAX Interface of LibXML</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
>&nbsp;</TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Conclusion</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>