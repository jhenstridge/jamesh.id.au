<?xml version="1.0"?> <?emacs -*- mode: nxml -*- ?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
          "http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd">
<article id="index">
  <articleinfo>
    <title>Using the SAX Interface of LibXML</title>
    <author>
      <firstname>James</firstname>
      <surname>Henstridge</surname>
      <affiliation>
	<address>
	  <email>james@daa.com.au</email>
	</address>
      </affiliation>
    </author>

    <abstract>
      <para>The libxml library provides two interfaces to the parser:
      a DOM style tree interface, and a SAX style event based
      interface.  Most users of the library choose the DOM interface
      due to its ease of use, however it does have a few drawbacks.
      The big drawback is that its memory usage is proportional to the
      size of the document, which can be a problem for large
      documents.</para>

      <para>In contrast, the SAX interface does not maintain the
      entire DOM tree in memory, which means that it can be quite
      efficient for large documents.</para>

      <para>This article is aimed at people who understand and have
      used the libxml DOM style interface and want to explore the SAX
      interface.  Some examples are aimed toward use in GTK+/GNOME
      programs.</para>
    </abstract>
  </articleinfo>
  
  <section id="introduction">
    <title>Introduction and Concepts</title>

    <para>Most people will agree that the most intuitive
    representation for arbitrary XML data is a tree.  Libxml provides
    a nice API to construct a tree from an XML file, which makes it
    very easy to use.  But in some cases, the tree representation does
    not match the internal representation you wish to use in your
    program, so it may not be the best choice.  You may end up using
    libxml to construct the tree, extracting the data and then throw
    away the tree.</para>

    <para>In these cases libxml's SAX API may be a better choice.
    Note that there are a few drawbacks to the use of this API
    though:</para>

    <itemizedlist>
      <listitem>
	<para>SAX parsers generally require you to write a bit more
	code than the DOM interface.</para>
      </listitem>
      <listitem>
	<para>Unless you build a DOM style tree from your
	application's internal representation for the data, you can't
	as easily write the XML file back to disk.  This is not a
	concern if your program only reads XML files, and does not
	write them.</para>
      </listitem>
      <listitem>
	<para>You may have to redesign or rethink your file loading
	routines.</para>
      </listitem>
    </itemizedlist>

    <para>It is not all bad however.  There are benefits to the use of
    the SAX API:</para>

    <itemizedlist>
      <listitem>
	<para>The DOM tree is not constructed, so there are
	potentially less memory allocations.</para>
      </listitem>
      <listitem>
	<para>If you convert the data in the DOM tree to another
	format, the SAX API may help remove the intermediate
	step.</para>
      </listitem>
      <listitem>
	<para>If you do not need all the XML data in memory, the SAX
	API allows you to process the data as it is parsed.</para>
      </listitem>
    </itemizedlist>

    <section id="intro-sax">
      <title>The SAX Interface</title>

      <para>As you know, the DOM style interface (ie. what is returned
      by <function>xmlParseFile</function> or
      <function>xmlParseMemory</function>) produces a tree of xmlNode
      structures that can then be walked to extract the data.</para>

      <para>The SAX interface works quite differently on the other
      hand.  You instead pass a number of callback routines to the
      parser in a <structname>xmlSAXHandler</structname> structure.
      The parser will then parse the document and call the appropriate
      callback when certain conditions occur.</para>

      <para>Some of the more useful callbacks are
      <function>startDocument</function>,
      <function>endDocument</function>,
      <function>startElement</function>,
      <function>endElement</function>, <function>getEntity</function>
      and <function>characters</function>.  Most of these are quite
      self explanatory.  The <function>characters</function> callback
      is called when characters outside a tag are parsed.</para>

      <para>As you can see, the code for a SAX style parser seems
      almost inside out, when compared with the DOM style tree method.
      For this reason, a state machine aproach is useful.</para>

      <para>It is interesting to note that the
      <function>xmlParseFile</function> function and friends are all
      implemented in terms of the SAX interface, so no power is lost
      by using this interface.</para>

    </section>

    <section id="intro-examples">
      <title>Some Examples</title>

      <para>To give you some idea of where SAX may be useful, some
      examples may help.</para>

      <section id="number-array">
	<title>An Array of Numbers</title>

	<para>Consider an XML document structured like follows:</para>
<programlisting><![CDATA[
<?xml version="1.0"?>
<array>
  <number>0</number>
  <number>1</number>
  ...
  <number>42</number>
</array>
]]></programlisting>

	<para>The file describes an array of numbers.  In this case,
	the most appropriate data structure to represent the
	information as would be an array -- not a tree.  By using the
	SAX interface, we can write the numbers directly to an array
	rather than using the DOM tree as an intermediate
	format.</para>

	<para>As I said earlier, state machines make using the SAX
	interface much easier.  At any one time, you are in one state.
	The <function>startElement</function> and
	<function>endElement</function> callbacks cause the
	state to change.  You will also want to perform some other
	actions during state changes -- in this case, build the
	array.</para>

	<para>For this example, we can use four states:</para>
	<simplelist>
	  <member>START</member>
	  <member>INSIDE_ARRAY</member>
	  <member>INSIDE_NUMBER</member>
	  <member>FINISH</member>
	</simplelist>

	<para>In the <function>startDocument</function> callback, we
	would initialise any variables that are required during
	parsing.  This would include the array to hold the numbers (a
	glib <structname>GArray</structname> would be useful), and a
	buffer to hold character data (a glib
	<structname>GString</structname> is a good choice here).  It
	would also set the initial state to START.  the
	<function>endDocument</function> callback, we can free these
	variables (we would leave the array though).</para>

	<para>The interesting code is in the
	<function>startElement</function> and
	<function>endElement</function> callbacks.  What they do will
	depend on the current state, and the element name that is
	being opened or closed.</para>

	<para>For the array example, the
	<function>startElement</function> function would act as
	follows:</para>

	<itemizedlist>
	  <listitem>
	    <para>If we are in the START state and the element name is
	    array, then change to the INSIDE_ARRAY state.  Any other
	    names would be an error</para>
	  </listitem>
	  <listitem>
	    <para>If we are in the INSIDE_ARRAY state, and the element
	    name is number, change to the INSIDE_NUMBER state.  We
	    would also zero the character data buffer.  Any other
	    element would be an error in this state.</para>
	  </listitem>
	  <listitem>
	    <para>If we are in the INSIDE_NUMBER or FINISH states, it
	    is an error.</para>
	  </listitem>
	</itemizedlist>

	<para>The <function>characters</function> function would
	append the character data to the buffer if it was in the
	INSIDE_NUMBER state.  If it is in any other states, the data
	could be discarded.</para>

	<para>The <function>endElement</function> function would act
	as follows:</para>
	<itemizedlist>
	  <listitem>
	    <para>If we are in the INSIDE_NUMBER state, the character
	    data buffer should hold the number.  We convert the string
	    to an integer and append it to the array.  We then change
	    to the INSIDE_ARRAY state.</para>
	  </listitem>
	  <listitem>
	    <para>If we are in the INSIDE_ARRAY state, change to the
	    FINNISH state.</para>
	  </listitem>
	  <listitem>
	    <para>If we are in the START or FINNISH states, an error
	    has occured</para>
	  </listitem>
	</itemizedlist>

	<para>Note that we know what to do in the
	<function>endElement</function> function even without looking
	at the element name.  By using a state machine model like
	this, we can narrow down the number of possible element names,
	which reduces string comparisons as well.</para>

      </section>

      <section id="large-xml-file">
	<title>Large Repetitive XML Files</title>

	<para>Sometimes we have XML files with many subtrees of the
	same format describing different things.  An example of this
	is the <filename>fullIndex.rdf.gz</filename> used by the
	<ulink url="http://www.rpmfind.net/">rpmfind program</ulink>.
	The file contains repeating sections like follows:</para>

<programlisting><![CDATA[
  ...
  <RDF:Description about="ftp://rpmfind.net/linux/redhat/redhat-6.0/i386/RedHat/RPMS/emacs-X11-20.3-15.i386.rpm">
    <RPM:Name>emacs-X11</RPM:Name>
    <RPM:Summary>The Emacs text editor for the X Window System.</RPM:Summary>
  </RDF:Description>
  <RDF:Description about=&quot;ftp://rpmfind.net/linux/Mandrake/6.0/Mandrake/RPMS/emacs-el-20.3-14mdk.i586.rpm">
    <RPM:Name>emacs-el</RPM:Name>
    <RPM:Summary>The sources for elisp programs included with Emacs.</RPM:Summary>
  </RDF:Description>
  ...
]]></programlisting>

	<para>One operation that we might want to do is to search for
	a package by name.  For this type of operation, at any one
	time, we are only concerned with one subtree in the document
	-- the others need not be in memory.  For this reason, a SAX
	based parser would be a good idea.</para>

	<para>With the DOM tree aproach, the memory usage of the
	program will increase as the size of the index file increases.
	With the SAX based aproach, the memory usage should be fairly
	constant despite changes in the size of the index.</para>

	<para>This benefit is particularly useful when parsing XML
	documents of sizes similar to the RDF dumps of the <ulink
	url="http://www.dmoz.org">Open Directory Project</ulink>.  The
	overhead of the DOM tree can become unacceptable when parsing
	35 megabyte XML files.</para>

	<para>For a working example of this sort of situation, see the
	XML parser in <ulink
	url="http://cvs.gnome.org/lxr/source/gnorpm/find/search.c"
	><filename>gnorpm/find/search.c</filename></ulink>.</para>

      </section>

      <section id="simple-tree-example">
	<title>Simple Tree Structures</title>

	<para>Sometimes it may make sense to use the SAX interface
	even if the data in the XML file is inherently tree
	based.</para>

	<para>The DOM style interface of libxml is designed to be able
	to represent any well formed XML document.  But the save
	format of most applications generally uses only a subset of
	XML.  For instance, GLADE does not use attributes for any
	elements, so you could argue that the support for attributes
	in the DOM interface is bloat when used with GLADE.</para>

	<para>Since the XML you are reading in has some known
	constraints, it is usually possible to store the information
	in more compact structures.</para>

	<para>I am looking at implementing something like this in
	libglade.  In this situation, the changeover looks like it
	will decrease the memory requirements of the internal
	structures by a factor of four, and has increased the speed of
	the parser slightly.</para>

	<para>You can look at the source for the new libglade SAX
	based parser in <ulink
	url="http://cvs.gnome.org/lxr/source/libglade/glade/glade-parser.c"
	><filename>libglade/glade/glade-parser.c</filename></ulink>.
	There is also a diagram that describes the transitions between
	the different states in the parser in <ulink
	url="http://cvs.gnome.org/lxr/source/libglade/doc/glade-2.0.dia"
	><filename>libglade/doc/glade-2.0.dia</filename></ulink>.</para>

	<para>In this particular type of situation, it is worth
	spending a bit more time deciding between DOM style and SAX
	interfaces.  If you keep with the DOM interface, your program
	will probably use a bit more memory, but it has the advantage
	that you can modify the tree, and then write the XML file back
	to disk with a single function call.  If you switch over to a
	different representation, you will need to either convert the
	information to the DOM style tree representation and then dump
	it to a file, or write your own output routines.</para>

	<para>Another deciding factor is laziness.  If you use the SAX
	interface, you will need to write some parsing code.  On the
	other hand, the DOM interface does this for you.</para>

	<para>In the libglade case, memory usage and speed were
	considered important, and the XML data did not have to be
	written back to a file, so choice of a SAX parser was
	relatively easy.</para>

      </section>

    </section>

  </section>

  <section id="implementing">
    <title>Implementing a SAX Based Parser</title>

    <para>Now you should have a pretty good idea about what a SAX
    parser is, and how you might implement one using a state machine
    design.  Now it is time to learn how to implement the parser using
    libxml's C translation of the SAX interface.</para>

    <section id="basics">
      <title>The Basics</title>

      <para>As stated before, you use the SAX parser by passing a
      number of callback routines stored in a
      <structname>xmlSAXHandler</structname> structure to one of the
      SAX parser routines.  Here is the prototype for the
      structure:</para>

<programlisting>
typedef struct <structname>xmlSAXHandler</structname> {
    internalSubsetSAXFunc <structfield>internalSubset</structfield>;
    isStandaloneSAXFunc <structfield>isStandalone</structfield>;
    hasInternalSubsetSAXFunc <structfield>hasInternalSubset</structfield>;
    hasExternalSubsetSAXFunc <structfield>hasExternalSubset</structfield>;
    resolveEntitySAXFunc <structfield>resolveEntity</structfield>;
    getEntitySAXFunc <structfield>getEntity</structfield>;
    entityDeclSAXFunc <structfield>entityDecl</structfield>;
    notationDeclSAXFunc <structfield>notationDecl</structfield>;
    attributeDeclSAXFunc <structfield>attributeDecl</structfield>;
    elementDeclSAXFunc <structfield>elementDecl</structfield>;
    unparsedEntityDeclSAXFunc <structfield>unparsedEntityDecl</structfield>;
    setDocumentLocatorSAXFunc <structfield>setDocumentLocator</structfield>;
    startDocumentSAXFunc <structfield>startDocument</structfield>;
    endDocumentSAXFunc <structfield>endDocument</structfield>;
    startElementSAXFunc <structfield>startElement</structfield>;
    endElementSAXFunc <structfield>endElement</structfield>;
    referenceSAXFunc <structfield>reference</structfield>;
    charactersSAXFunc <structfield>characters</structfield>;
    ignorableWhitespaceSAXFunc <structfield>ignorableWhitespace</structfield>;
    processingInstructionSAXFunc <structfield>processingInstruction</structfield>;
    commentSAXFunc <structfield>comment</structfield>;
    warningSAXFunc <structfield>warning</structfield>;
    errorSAXFunc <structfield>error</structfield>;
    fatalErrorSAXFunc <structfield>fatalError</structfield>;
} <structname>xmlSAXHandler</structname>;
typedef <structname>xmlSAXHandler</structname> *xmlSAXHandlerPtr;
</programlisting>

      <para>To start off with, we can set all these functions to NULL.
      If we use a NULL SAX parser like this, then we will have a
      parser that only checks that the document is well formed.  By
      adding a few callbacks, we can get it to do just about
      anything.</para>

      <para>In order to parse a document, you will use one of the
      following two functions, depending on whether the XML file is in
      a memory buffer or a file:</para>

      <funcsynopsis>
	<funcsynopsisinfo>#include &lt;libxml/parser.h&gt;</funcsynopsisinfo>
	<funcprototype>
	  <funcdef>int <function>xmlSAXUserParseFile</function></funcdef>
	  <paramdef>xmlSAXHandlerPtr <parameter>sax</parameter></paramdef>
          <paramdef>void *<parameter>user_data</parameter></paramdef>
	  <paramdef>const char *<parameter>filename</parameter></paramdef>
	</funcprototype>
	<funcprototype>
	  <funcdef>int <function>xmlSAXUserParseMemory</function></funcdef>
	  <paramdef>xmlSAXHandlerPtr <parameter>sax</parameter></paramdef>
          <paramdef>void *<parameter>user_data</parameter></paramdef>
	  <paramdef>char *<parameter>buffer</parameter></paramdef>
	  <paramdef>int <parameter>size</parameter></paramdef>
	</funcprototype>
      </funcsynopsis>

      <para>The <parameter>user_data</parameter> argument of these
      functions allows you to pass in a structure to hold the state of
      your parser.  This allows us to make the parser reentrant, which
      would not be possible if global variables were used to hold the
      parser state.</para>

      <para>Here is an example of how to call your parser to parse a
      file:</para>

<programlisting>
#include &lt;libxml/parser.h&gt;

static <structname>xmlSAXHandler</structname> my_handler {
    ...
};

struct <structname>ParserState</structname> {
    RetVal <structfield>return_val</structfield>;
    StatesEnum <structfield>state</structfield>;
    ...
};

RetVal
<function>parse_xml_file</function>(const char *<parameter>filename</parameter>) {
    struct ParserState my_state;

    if (xmlSAXUserParseFile(&amp;my_handler, &amp;my_state, filename) &lt; 0) {
        free_ret_val(my_state.return_val);
        return NULL;
    } else
        return my_state.return_val;
}
</programlisting>

      <para>In this example, we expect the
      <function>startDocument</function> SAX handler to initialise the
      <structname>ParserState</structname> structure passed to it, and
      the <function>endDocument</function> to free its members, but
      leaving <structfield>return_val</structfield> so that it can be
      used later.</para>

    </section>

    <section id="start-end-doc">
      <title>The startDocument and endDocument Callbacks</title>

      <para>These callbacks are generally used to perform some
      initialisation and deinitialisation for your parser callbacks.
      Their prototypes are as follows:</para>

      <funcsynopsis>
	<funcprototype>
	  <funcdef>void <function>startDocument</function></funcdef>
	  <paramdef>void *<parameter>user_data</parameter></paramdef>
	</funcprototype>
	<funcprototype>
	  <funcdef>void <function>endDocument</function></funcdef>
	  <paramdef>void *<parameter>user_data</parameter></paramdef>
	</funcprototype>
      </funcsynopsis>

      <para>It should be fairly self explanatory how to write these
      functions.</para>

    </section>

    <section id="characters">
      <title>The characters Callback</title>

      <para>The <function>characters</function> callback is called
      when there are characters that are outside of tags get parsed.
      Its prototype is as follows:</para>

      <funcsynopsis>
	<funcprototype>
	  <funcdef>void <function>characters</function></funcdef>
	  <paramdef>void *<parameter>user_data</parameter></paramdef>
	  <paramdef>const xmlChar *<parameter>ch</parameter></paramdef>
	  <paramdef>int <parameter>len</parameter></paramdef>
	</funcprototype>
      </funcsynopsis>

      <para>The <type>xmlChar</type> type is used by libxml in places
      where it expects to receive, or provides valid UTF-8 data.  In
      most cases, you can think of <parameter>ch</parameter> as a
      normal character string, although for correct processing you
      will need to use the UTF-8 functions in glib.  Note that the
      character data is not necessarily nul terminated.  This is so
      that libxml does not need to copy the character data out of its
      internal buffers before passing it to the callback.</para>

      <para>In your callback, you will probably want to copy the
      characters to some other buffer so that it can be used from the
      endElement callback.  To optimise this callback a bit, you might
      adjust the callback so that it only copies the characters if the
      parser is in a certain state.  Note that the
      <function>characters</function> callback may be called more than
      once between calls to <function>startElement</function> and
      <function>endElement</function>.</para>

    </section>

    <section id="start-end-element">
      <title>The startElement and endElement Callbacks</title>

      <para>These callbacks are where most of the state machine logic
      will go into these two callbacks.  Their prototypes are:</para>

      <funcsynopsis>
	<funcprototype>
	  <funcdef>void <function>startElement</function></funcdef>
	  <paramdef>void *<parameter>user_data</parameter></paramdef>
	  <paramdef>const xmlChar *<parameter>name</parameter></paramdef>
	  <paramdef>const xmlChar **<parameter>attrs</parameter></paramdef>
	</funcprototype>
	<funcprototype>
	  <funcdef>void <function>endElement</function></funcdef>
	  <paramdef>void *<parameter>user_data</parameter></paramdef>
	  <paramdef>const xmlChar *<parameter>name</parameter></paramdef>
	</funcprototype>
      </funcsynopsis>

      <para>In these callbacks, the <parameter>name</parameter>
      parameter is the name of the element.  The
      <parameter>attrs</parameter> parameter contains the attributes
      for the start tag.  The even indices in the array will be
      attribute names, the odd indices are the values, and the final
      index will contain a NULL.</para>

      <para>In most parsers, as well as making state transitions in
      these callbacks, you will probably also collect the data in the
      XML file. In the <function>startElement</function> callback, you
      will often allocate structures to hold the data.  In the
      <function>endElement</function> callback, you will usually
      interpret the character data collected by the
      <function>characters</function> callback and put the data in one
      of the structures allocated by
      <function>startElement</function>.  The
      <function>endElement</function> callback may also free some of
      the intermediate structures if it is no longer needed.</para>

    </section>

    <section id="entities">
      <title>The getEntity Callback</title>

      <para>You may have been wondering how entities (eg &amp;lt;,
      etc) are handled by the SAX interface.  This is done by the
      <function>getEntity</function> callback:</para>

      <funcsynopsis>
	<funcprototype>
	  <funcdef>xmlEntityPtr <function>getEntity</function></funcdef>
	  <paramdef>void *<parameter>user_data</parameter></paramdef>
	  <paramdef>const xmlChar *<parameter>name</parameter></paramdef>
	</funcprototype>
      </funcsynopsis>

      <para>The <structname>xmlEntity</structname> structure holds
      some information about the entity.  This structure will not be
      freed by the parser, so it makes sense to create these
      structures once, and then pass a pointer to the appropriate one
      when this function is called.  After calling
      <function>getEntity</function>, the expansion of the entity is
      passed to the <function>characters</function> callback.  This
      way, you do not need to worry about decoding entities anywhere
      else in your callback routines.</para>

      <para>If your XML document only contains the standard entities
      (&amp;lt;, &amp;gt;, &amp;apos;, &amp;quot; and &amp;amp;), then
      it is possible to write a very short implementation for this
      callback:</para>

<programlisting><![CDATA[
static xmlEntityPtr
my_getEntity(void *user_data, const xmlChar *name) {
    return xmlGetPredefinedEntity(name);
}
]]></programlisting>

      <para>For most parsers, this will be sufficient.</para>

    </section>

    <section id="errors">
      <title>Structural Errors</title>

      <para>If there are structural errors in the XML file, the parser
      will call one of three error callbacks:
      <function>warning</function>, <function>error</function> or
      <function>fatalError</function>.</para>

      <para>If you want to pass these errors to the standard glib
      logging functions, you might want to use an implementation
      something like this:</para>

<programlisting><![CDATA[
static void
my_warning(void *user_data, const char *msg, ...) {
    va_list args;

    va_start(args, msg);
    g_logv("XML", G_LOG_LEVEL_WARNING, msg, args);
    va_end(args);
}

static void
my_error(void *user_data, const char *msg, ...) {
    va_list args;

    va_start(args, msg);
    g_logv("XML", G_LOG_LEVEL_CRITICAL, msg, args);
    va_end(args);
}

static void
my_fatalError(void *user_data, const char *msg, ...) {
    va_list args;

    va_start(args, msg);
    g_logv("XML", G_LOG_LEVEL_ERROR, msg, args);
    va_end(args);
}
]]></programlisting>

      <para>Note that libxml is not a validating parser, so only
      structural errors will be picked up.  So any validation of the
      format will have to be done by your parser routines.</para>

    </section>

    <section id="expansion">
      <title>How to Handle an Expanding File Format</title>

      <para>With most applications, you will want to add to the XML
      file format as you add features to the application.  For this
      reason, you will want to code your callbacks so that they don't
      barf on an unknown or unexpected tag.</para>

      <para>With the DOM style interface, if you come to a node with
      an unexpected name, you will usually ignore it, and the subtree
      under it.  It is probably a good idea to use a similar process
      for a SAX based parser.</para>

      <para>To implement this sort of error recovery, we will need an
      extra state for the parser -- UNKNOWN.  We will also need to
      pass two extra variables in the <parameter>user_data</parameter>
      parameter to the callbacks -- prev_state and unknown_depth.</para>

      <para>When we hit an unknown element in the
      <function>startElement</function> callback, we can save the
      current state to prev_state, and then change the state to
      UNKNOWN, and set unknown_depth to 1.  If
      <function>startElement</function> is called while in the UNKNOWN
      state, we increment the unknown_depth variable.</para>

      <para>In the <function>endElement</function> callback, if we are
      in the UNKNOWN state, decrement unknown_depth.  If unknown_depth
      is zero, change the state to prev_state.  The
      <function>characters</function> callback should probably return
      immediately if in the UNKNOWN state as well.</para>

      <para>Using this sort of logic, it should be possible to ignore
      unknown sections of the document quite easily.  The UNKNOWN
      state is also useful when writing the parser.  This way you can
      test out portions of the parser before it is complete.</para>

    </section>

  </section>

  <section id="conclusion">
    <title>Conclusion</title>

    <para>This tutorial should have given you a good idea about how to
    think about writing SAX parsers, and how to implement them with
    libxml.  If you want more information about the other callbacks,
    look at the libxml API documentation.</para>

    <para>Another place for information on SAX is the <ulink
    url="http://www.saxproject.org/">Simple API for XML</ulink> page.
    It is concerned with the original java implementation, but many of
    the concepts should be useful with libxml.</para>

  </section>

</article>
